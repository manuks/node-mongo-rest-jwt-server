{
  "name": "jsonwebtoken",
  "version": "1.1.2",
  "description": "JSON Web Token implementation (symmetric and asymmetric)",
  "main": "index.js",
  "scripts": {
    "test": "mocha"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/auth0/node-jsonwebtoken"
  },
  "keywords": [
    "jwt"
  ],
  "author": {
    "name": "auth0"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/auth0/node-jsonwebtoken/issues"
  },
  "dependencies": {
    "jws": "~0.2.6"
  },
  "devDependencies": {
    "chai": "*",
    "mocha": "*"
  },
  "readme": "# jsonwebtoken [![Build Status](https://secure.travis-ci.org/auth0/node-jsonwebtoken.png)](http://travis-ci.org/auth0/node-jsonwebtoken)\n\n\nAn implementation of [JSON Web Tokens](http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html).\n\nThis was developed against `draft-ietf-oauth-json-web-token-08`. It makes use of [node-jws](https://github.com/brianloveswords/node-jws)\n\n# Install\n\n```bash\n$ npm install jsonwebtoken\n```\n\n# Usage\n\n### jwt.sign(payload, secretOrPrivateKey, options)\n\n(Synchronous) Returns the JsonWebToken as string\n\n`payload` could be an literal, buffer or string\n\n`secretOrPrivateKey` is a string or buffer containing either the secret for HMAC algorithms, or the PEM\nencoded private key for RSA and ECDSA.\n\n`options`:\n\n* `algorithm` (default: `HS256`)\n* `expiresInMinutes`\n* `audience`\n* `subject`\n* `issuer`\n\nIf `payload` is not a buffer or a string, it will be coerced into a string\nusing `JSON.stringify`.\n\nIf any `expiresInMinutes`, `audience`, `subject`, `issuer` are not provided, there is no default. The  jwt generated won't include those properties in the payload.\n\nExample\n\n```js\n// sign with default (HMAC SHA256)\nvar jwt = require('jsonwebtoken');\nvar token = jwt.sign({ foo: 'bar' }, 'shhhhh');\n\n// sign with RSA SHA256\nvar cert = fs.readFileSync('private.key');  // get private key\nvar token = jwt.sign({ foo: 'bar' }, cert, { algorithm: 'RS256'});\n```\n\n### jwt.verify(token, secretOrPublicKey, options, callback)\n\n(Synchronous with callback) Returns the payload decoded if the signature (and optionally expiration, audience, issuer) are valid. If not, it will return the error.\n\n`token` is the JsonWebToken string\n\n`secretOrPublicKey` is a string or buffer containing either the secret for HMAC algorithms, or the PEM\nencoded public key for RSA and ECDSA.\n\n`options`\n\n* `audience`: if you want to check audience (`aud`), provide a value here\n* `issuer`: if you want to check issuer (`iss`), provide a value here\n\n```js\n// verify a token symmetric\njwt.verify(token, 'shhhhh', function(err, decoded) {\n  console.log(decoded.foo) // bar\n});\n\n// invalid token\njwt.verify(token, 'wrong-secret', function(err, decoded) {\n  // err \n  // decoded undefined\n});\n\n// verify a token asymmetric\nvar cert = fs.readFileSync('public.pem');  // get public key\njwt.verify(token, cert, function(err, decoded) {\n  console.log(decoded.foo) // bar\n});\n\n// verify audience\nvar cert = fs.readFileSync('public.pem');  // get public key\njwt.verify(token, cert, { audience: 'urn:foo' }, function(err, decoded) {\n  // if audience mismatch, err == invalid audience\n});\n\n// verify issuer\nvar cert = fs.readFileSync('public.pem');  // get public key\njwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer' }, function(err, decoded) {\n  // if issuer mismatch, err == invalid issuer\n});\n      \n```\n\n### jwt.decode(token)\n\n(Synchronous) Returns the decoded payload without verifying if the signature is valid.\n\n`token` is the JsonWebToken string\n\nExample\n\n```js\n// get the decoded payload ignoring signature, no secretOrPrivateKey needed\nvar decoded = jwt.decode(token);\n```\n\n## Errors & Codes\nPossible thrown errors during verification.\nError is the first argument of the verification callback.\n\n### TokenExpiredError\n\nThrown error if the token is expired.\n\nError object:\n\n* name: 'TokenExpiredError'\n* message: 'jwt expired'\n* expiredAt: [ExpDate]\n\n```js\njwt.verify(token, 'shhhhh', function(err, decoded) {\n  if (err) {\n    /* \n      err = {\n        name: 'TokenExpiredError',\n        message: 'jwt expired',\n        expiredAt: 1408621000\n      }\n    */\n  }\n});\n```\n\n### JsonWebTokenError\nError object:\n\n* name: 'JsonWebTokenError'\n* message:\n  * 'jwt malformed'\n  * 'jwt signature is required'\n  * 'invalid signature'\n  * 'jwt audience invalid. expected: [PAYLOAD AUDIENCE]'\n  * 'jwt issuer invalid. expected: [PAYLOAD ISSUER]'\n\n```js\njwt.verify(token, 'shhhhh', function(err, decoded) {\n  if (err) {\n    /* \n      err = {\n        name: 'JsonWebTokenError',\n        message: 'jwt malformed'\n      }\n    */\n  }\n});\n```\n\n## Algorithms supported\n\nArray of supported algorithms. The following algorithms are currently supported.\n\nalg Parameter Value | Digital Signature or MAC Algorithm \n----------------|----------------------------\nHS256 | HMAC using SHA-256 hash algorithm \nHS384 | HMAC using SHA-384 hash algorithm \nHS512 | HMAC using SHA-512 hash algorithm \nRS256 | RSASSA using SHA-256 hash algorithm\nRS384 | RSASSA using SHA-384 hash algorithm\nRS512 | RSASSA using SHA-512 hash algorithm\nES256 | ECDSA using P-256 curve and SHA-256 hash algorithm\nES384 | ECDSA using P-384 curve and SHA-384 hash algorithm\nES512 | ECDSA using P-521 curve and SHA-512 hash algorithm\nnone | No digital signature or MAC value included\n\n\n\n# TODO\n\n* X.509 certificate chain is not checked\n\n# License\n\nMIT\n\n",
  "readmeFilename": "README.md",
  "homepage": "https://github.com/auth0/node-jsonwebtoken",
  "_id": "jsonwebtoken@1.1.2",
  "_shasum": "b231c30b96f01429289eed6f93bf5ce5ae4943c5",
  "_from": "jsonwebtoken@",
  "_resolved": "https://registry.npmjs.org/jsonwebtoken/-/jsonwebtoken-1.1.2.tgz"
}
